<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title></title><meta content="" name="description"/><meta content="" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../lib/jquery.min.js"></script><script type="text/javascript" src="../../lib/index.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript" src="../../lib/scheduler.js"></script><script type="text/javascript" src="../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../';</script></head><body><div id="search"><span id="doc-title"><span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.com" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="com"></a><a id="com:com"></a> <span class="permalink"><a href="../../com/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">com</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 current" name="com.loopfor" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="loopfor"></a><a id="loopfor:loopfor"></a> <span class="permalink"><a href="../../com/loopfor/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">loopfor</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="com" id="com" class="extype">com</a></dd></dl></div></li><li class="indented3 " name="com.loopfor.scalop" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scalop"></a><a id="scalop:scalop"></a> <span class="permalink"><a href="../../com/loopfor/scalop/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="scalop/index.html" title="A simple option parser."><span class="name">scalop</span></a></span><p class="shortcomment cmt">A simple option parser.</p><div class="fullcomment"><div class="comment cmt"><p>A simple option parser.</p><h6>Overview</h6><p>An option parser is an ordered collection of <a href="scalop/OptName.html" name="com.loopfor.scalop.OptName" id="com.loopfor.scalop.OptName" class="extype">option name</a> and <a href="scalop/index.html#OptProcessor[+A]=Seq[String]=&gt;(Seq[String],A)" name="com.loopfor.scalop.OptProcessor" id="com.loopfor.scalop.OptProcessor" class="extmbr">option processor</a> pairs that
matches on a sequence of arguments, yielding a map of option names to option values. As the parser recognizes option names
in the argument sequence, it applies the corresponding processor function to obtain the option value. This process is
repeated until the argument sequence is exhausted or the parser encounters an error.</p><p>An <a href="scalop/OptName.html" name="com.loopfor.scalop.OptName" id="com.loopfor.scalop.OptName" class="extype">option name</a> can be expressed in both <i>long</i> and <i>short</i> form. For any given sequence of arguments,
<i>long</i> options are detected by the presence of a <code>--</code> prefix and <i>short</i> options with a <code>-</code> prefix. Examples include
<code>--verbose</code> and <code>-v</code>, respectively.</p><p>An <a href="scalop/index.html#OptProcessor[+A]=Seq[String]=&gt;(Seq[String],A)" name="com.loopfor.scalop.OptProcessor" id="com.loopfor.scalop.OptProcessor" class="extmbr">option processor</a> is an arbitrary function whose purpose is to return a value that gets assigned to the
option name. A processor may consider and absorb subsequent arguments in computing the value, such as <code>--timeout</code> that might
expect the next argument to be an integer. Library users are encouraged to utilize the predefined builder methods rather
than implement processor functions from scratch.</p><h6>Option Construction</h6><p>The construction of an <a href="scalop/Opt.html" name="com.loopfor.scalop.Opt" id="com.loopfor.scalop.Opt" class="extype">option</a> is best done using the DSL, which is available from the following import statement.</p><pre><span class="kw">import</span> com.loopfor.scalop._</pre><p>The following is a simple option that demonstrates how the DSL is used to pair an option name with a corresponding
processor.</p><pre><span class="kw">val</span> opt = (<span class="lit">"verbose"</span>, <span class="lit">'v'</span>) ~&gt; just(<span class="kw">true</span>)</pre><p>The <a href="scalop/OptName.html#~&gt;[A](fn:com.loopfor.scalop.OptProcessor[A]):com.loopfor.scalop.Opt[A]" name="com.loopfor.scalop.OptName#~&gt;" id="com.loopfor.scalop.OptName#~&gt;" class="extmbr">~&gt;</a> method triggers an implicit conversion of the tuple <code>("verbose", 'v')</code> into an option name and then
binds the processor function <code>just(true)</code>, resulting in an option.</p><p>An option can also be adorned with a default value upon construction using the <a href="scalop/Opt.html#~~[B&gt;:A](default:B):com.loopfor.scalop.Opt[B]" name="com.loopfor.scalop.Opt#~~" id="com.loopfor.scalop.Opt#~~" class="extmbr">~~</a> operator following the
processor function. Doing so ensures that the option is assigned the default value in the absence of being specified in an
argument sequence at the time of parsing.</p><pre><span class="kw">val</span> opt = (<span class="lit">"verbose"</span>, <span class="lit">'v'</span>) ~&gt; just(<span class="kw">true</span>) ~~ <span class="kw">false</span></pre><p>A sequence of options can then be constructed using the <code>::</code> operator. Note that the order of options is important since the
parser will evaluate arguments against those options based on traversal order of the sequence.</p><pre><span class="kw">val</span> opts = (<span class="lit">"verbose"</span>, <span class="lit">'v'</span>) ~&gt; just(<span class="kw">true</span>) ~~ <span class="kw">false</span> ::
           (<span class="lit">"timeout"</span>, <span class="lit">'t'</span>) ~&gt; as[<span class="std">Int</span>] ~~ <span class="num">0</span> ::
           <span class="lit">"encoding"</span> ~&gt; as[Charset] ~~ Charset.forName(<span class="lit">"UTF-8"</span>) ::
           <span class="lit">'?'</span> ~&gt; just(<span class="kw">true</span>) ~~ <span class="kw">false</span> ::
           Nil</pre><h6>Replacing Options</h6><p>A <i>replacing</i> option is one which replaces values previously assigned to an option name during argument parsing. Options
of this type are created using the <a href="scalop/OptName.html#~&gt;[A](fn:com.loopfor.scalop.OptProcessor[A]):com.loopfor.scalop.Opt[A]" name="com.loopfor.scalop.OptName#~&gt;" id="com.loopfor.scalop.OptName#~&gt;" class="extmbr">~&gt;</a> operator.</p><p>For example:</p><pre><span class="kw">val</span> opt = <span class="lit">"timeout"</span> ~&gt; as[<span class="std">Int</span>]</pre><p>Given the following sequence of arguments, the value of <code>timeout</code> at the completion of parsing would be <code>60</code>.</p><pre>--timeout <span class="num">30</span> --timeout <span class="num">60</span></pre><h6>Appending Options</h6><p>An <i>appending</i> option is one which appends values to a sequence of values previously assigned to an option name during
argument parsing. Options of this type are created using the <a href="scalop/OptName.html#~&gt;+[A](fn:com.loopfor.scalop.OptProcessor[A]):com.loopfor.scalop.Opt[A]" name="com.loopfor.scalop.OptName#~&gt;+" id="com.loopfor.scalop.OptName#~&gt;+" class="extmbr">~&gt;+</a> operator.</p><p>For example:</p><pre><span class="kw">val</span> opt = <span class="lit">"server"</span> ~&gt;+ as[<span class="std">String</span>]</pre><p>Given the following sequence of arguments, the value of <code>server</code> at the completion of parsing would be
<code>Seq("foo.com", "bar.com")</code>.</p><pre>--server foo.com --server bar.com</pre><h6>Parser Construction</h6><p>The construction of an <a href="scalop/OptParser.html" name="com.loopfor.scalop.OptParser" id="com.loopfor.scalop.OptParser" class="extype">option parser</a> happens implicitly when the <a href="scalop/OptParser.html#&lt;~(args:Seq[String]):com.loopfor.scalop.OptResult" name="com.loopfor.scalop.OptParser#&lt;~" id="com.loopfor.scalop.OptParser#&lt;~" class="extmbr">&lt;~</a> operator is applied to
either a single option or a sequence of options.</p><p>The following illustrates the evaluation of arguments against a sequence of options. Note that an ephemeral instance of
an option parser is constructed as a byproduct of applying the <code>&lt;~</code> operator.</p><pre><span class="kw">val</span> opts = (<span class="lit">"verbose"</span>, <span class="lit">'v'</span>) ~&gt; just(<span class="kw">true</span>) ~~ <span class="kw">false</span> ::
           (<span class="lit">"timeout"</span>, <span class="lit">'t'</span>) ~&gt; as[<span class="std">Int</span>] ~~ <span class="num">0</span> ::
           <span class="lit">"encoding"</span> ~&gt; as[Charset] ~~ Charset.forName(<span class="lit">"UTF-8"</span>) ::
           <span class="lit">'?'</span> ~&gt; just(<span class="kw">true</span>) ~~ <span class="kw">false</span> ::
           Nil

<span class="kw">val</span> optr = opts &lt;~ <span class="std">Seq</span>(<span class="lit">"--verbose"</span>, <span class="lit">"-t"</span>, <span class="lit">"30"</span>, <span class="lit">"--encoding"</span>, <span class="lit">"iso-8859-1"</span>, <span class="lit">"this"</span>, <span class="lit">"and"</span>, <span class="lit">"that"</span>)</pre><p>In the aforementioned example, invoking the parser with the given sequence of arguments produces an
<a href="scalop/OptResult.html" name="com.loopfor.scalop.OptResult" id="com.loopfor.scalop.OptResult" class="extype">option result</a> containing a map of option names to option values. Notice that a value is associated with both
<i>long</i> and <i>short</i> forms of the option name regardless of which form is specified in the argument sequence.</p><pre><span class="lit">"verbose"</span> -&gt; <span class="kw">true</span>
<span class="lit">"v"</span> -&gt; <span class="kw">true</span>
<span class="lit">"timeout"</span> -&gt; <span class="num">30</span>
<span class="lit">"t"</span> -&gt; <span class="num">30</span>
<span class="lit">"encoding"</span> -&gt; Charset(ISO-<span class="num">8859</span>-<span class="num">1</span>)
<span class="lit">"?"</span> -&gt; <span class="kw">false</span>
<span class="lit">"@"</span> -&gt; <span class="std">Seq</span>(<span class="lit">"this"</span>, <span class="lit">"and"</span>, <span class="lit">"that"</span>)</pre><p>The <code>@</code> option is a special name containing all non-option values trailing the last option in the argument sequence.</p><h6>Parser Behavior</h6><p>Given a sequence of arguments, such as those provided by a shell when supplying arguments to a command line program, an
option parser behaves in the following manner.</p><p>The parser recursively applies the following algorithm as it traverses the argument sequence.</p><ul><li>If the next argument is equal to <code>"--"</code>, the sequence of all subsequent arguments is assigned to the special option name
 <code>"@"</code> and the parser terminates, returning the option value map. By convention, the <code>--</code> option is used to explicitly
 terminate options so that remaining arguments, which might be prefixed with <code>--</code> or <code>-</code>, are not treated as options.</li><li>If the next argument is either a <i>long</i> or <i>short</i> option name recognized by the parser, the corresponding processor
 function is applied to the remaining arguments, yielding a value, which is then associated with the option name, both
 <i>long</i> and <i>short</i>, in the option value map. However, if the argument happens to be an option that is not recognized by
 the parser, then an <a href="scalop/OptException.html" name="com.loopfor.scalop.OptException" id="com.loopfor.scalop.OptException" class="extype">exception</a> is thrown. Otherwise, the parser is recursively applied to the remaining
 sequence of arguments.</li><li>If the next argument is not an option, implying that it contains neither a <code>--</code> nor a <code>-</code> prefix, then the remaining
 argument sequence is assigned to the <code>"@"</code> option and the parser terminates.</li></ul><p>Finally, default values for each option are assigned to the option value map if values for those corresponding options are
absent.</p><p>In cases where values, which follow an option, contain either a <code>-</code> or <code>--</code> prefix, such values must be escaped by
prepending the <code>\</code> character. Otherwise, the parser will interpret the value as an option and proceed accordingly.</p><p>The following example will parse incorrectly since <code>-10</code> will be interpreted as an option.</p><pre>--time-adjust -<span class="num">10</span></pre><p>The correct way to specify this value is as follows:</p><pre>--time-adjust \-<span class="num">10</span></pre><h6>Option Processors</h6><p>An <a href="scalop/index.html#OptProcessor[+A]=Seq[String]=&gt;(Seq[String],A)" name="com.loopfor.scalop.OptProcessor" id="com.loopfor.scalop.OptProcessor" class="extmbr">option processor</a> is a function accepting as input:</p><ul><li>the sequence of arguments that follow an option name</li></ul><p>and returning as output a tuple containing:</p><ul><li>the sequence of arguments following those consumed by the processor</li><li>the option value</li></ul><p>The argument sequence provided as input are those that follow the recognized option. For example, given the following
argument sequence:</p><p><pre>
--verbose -F foo.out --timeout 10
</pre></p><p>Assuming <code>-F</code> was recognized by the parser, then the sequence provided to the associated processor function would be:</p><pre><span class="std">Seq</span>(<span class="lit">"foo.out"</span>, <span class="lit">"--timeout"</span>, <span class="lit">"10"</span>)</pre><p>Since a processor may expect additional arguments following the option, as is the case with <code>-F</code>, the resulting sequence
will be the arguments that follow those absorbed by the processor, which in this case, would be:</p><pre><span class="std">Seq</span>(<span class="lit">"--timeout"</span>, <span class="lit">"10"</span>)</pre><p>In cases where a processor requires additional arguments, it is often necessary to perform some degree of validation or
transformation, both of which may fail. Exceptions that propagate beyond the processor function are caught by the parser
and converted to <a href="scalop/OptException.html" name="com.loopfor.scalop.OptException" id="com.loopfor.scalop.OptException" class="extype">OptException</a>. Additionally, the <code>yell()</code> methods are provided as a convenience for processor
implementations to throw instances of <a href="scalop/OptException.html" name="com.loopfor.scalop.OptException" id="com.loopfor.scalop.OptException" class="extype">OptException</a>.</p><h6>Processor Construction</h6><p>A processor is typically constructed using one of the predefined builders, the choice of which depends on the nature of the
option.</p><p>For standalone options with no additional argument, the <a href="scalop/index.html#just[A](fn:=&gt;A):com.loopfor.scalop.package.OptProcessor[A]" name="com.loopfor.scalop#just" id="com.loopfor.scalop#just" class="extmbr">just</a> builder can be used to explicitly assign a value.</p><pre>(<span class="lit">"verbose"</span>, <span class="lit">'v'</span>) ~&gt; just(<span class="kw">true</span>)</pre><p>For options that contain one additional argument, the <a href="scalop/index.html#as[A,B](fn:A=&gt;B)(implicitconverter:com.loopfor.scalop.package.ArgConverter[A]):com.loopfor.scalop.package.OptProcessor[B]" name="com.loopfor.scalop#as" id="com.loopfor.scalop#as" class="extmbr">as</a> builders simplify
construction of the processor by standardizing the manner in which error cases are handled, such as missing arguments and
problems encountered with argument converters.</p><p>The simplest form of using <a href="scalop/index.html#as[A](implicitconverter:com.loopfor.scalop.package.ArgConverter[A]):com.loopfor.scalop.package.OptProcessor[A]" name="com.loopfor.scalop#as" id="com.loopfor.scalop#as" class="extmbr">as</a> follows, which essentially converts the argument into
the parameterized type.</p><pre>(<span class="lit">"timeout"</span>, <span class="lit">'t'</span>) ~&gt; as[<span class="std">Int</span>]</pre><p>As with all uses of <code>as</code>, an <a href="scalop/index.html#ArgConverter[A]=String=&gt;Either[String,A]" name="com.loopfor.scalop.ArgConverter" id="com.loopfor.scalop.ArgConverter" class="extmbr">argument converter</a> must be implicitly defined or supplied directly to the
function. Argument converters are discussed in more detail below.</p><p>A secondary form of using <a href="scalop/index.html#as[A,B](fn:A=&gt;B)(implicitconverter:com.loopfor.scalop.package.ArgConverter[A]):com.loopfor.scalop.package.OptProcessor[B]" name="com.loopfor.scalop#as" id="com.loopfor.scalop#as" class="extmbr">as</a> accepts a user-supplied function, which performs
additional processing on the argument once converted. The result of that function becomes the value of the option.</p><p>The following example illustrates how a function can be used for validation or alteration.</p><pre>(<span class="lit">"timeout"</span>, <span class="lit">'t'</span>) ~&gt; as { arg: <span class="std">Int</span> <span class="kw">=&gt;</span> <span class="kw">if</span> (arg &lt; <span class="num">0</span>) <span class="num">0</span> <span class="kw">else</span> arg }</pre><p>The type of the return value does not need to match the type of the converted argument, which is demonstrated below.</p><pre>(<span class="lit">"timeout"</span>, <span class="lit">'t'</span>) ~&gt; as { arg: <span class="std">Int</span> <span class="kw">=&gt;</span> (<span class="kw">if</span> (arg &lt; <span class="num">0</span>) <span class="num">0</span> <span class="kw">else</span> arg).seconds }</pre><p>For options that <i>might</i> contain an additional argument, the <a href="scalop/index.html#maybe[A,B](fn:A=&gt;B)(implicitconverter:com.loopfor.scalop.package.ArgConverter[A]):com.loopfor.scalop.package.OptProcessor[Option[B]]" name="com.loopfor.scalop#maybe" id="com.loopfor.scalop#maybe" class="extmbr">maybe</a> builders
are similar to their <code>as</code> counterparts in that the handling of error cases is standardized. All processors constructed in
this manner yield <code>Option[A]</code> rather than <code>A</code>. This is necessary to distinguish between the presence or absence of a
subsequent argument.</p><p>The simplest form of using <a href="scalop/index.html#maybe[A](implicitconverter:com.loopfor.scalop.package.ArgConverter[A]):com.loopfor.scalop.package.OptProcessor[Option[A]]" name="com.loopfor.scalop#maybe" id="com.loopfor.scalop#maybe" class="extmbr">maybe</a> is demonstrated below.</p><pre><span class="kw">val</span> opts = <span class="lit">"help"</span> ~&gt; maybe[<span class="std">String</span>]</pre><p>The value of the option will vary depending on the arguments provided to the parser:</p><pre>optr = opts &lt;~ <span class="std">Seq</span>()
optr(<span class="lit">"help"</span>) <span class="cmt">// undefined</span>

optr = opts &lt;~ <span class="std">Seq</span>(<span class="lit">"--help"</span>)
optr(<span class="lit">"help"</span>) == <span class="std">None</span>

optr = opts &lt;~ <span class="std">Seq</span>(<span class="lit">"--help"</span>, <span class="lit">"foo"</span>)
optr(<span class="lit">"help"</span>) == <span class="std">Some</span>(<span class="lit">"foo"</span>)</pre><p>A secondary form of using <a href="scalop/index.html#maybe[A,B](fn:A=&gt;B)(implicitconverter:com.loopfor.scalop.package.ArgConverter[A]):com.loopfor.scalop.package.OptProcessor[Option[B]]" name="com.loopfor.scalop#maybe" id="com.loopfor.scalop#maybe" class="extmbr">maybe</a> accepts a user-supplied function, but is
invoked only if a subsequent argument is present.</p><pre><span class="lit">"help"</span> ~&gt; maybe { arg: <span class="std">String</span> <span class="kw">=&gt;</span> <span class="kw">if</span> (canHelp(arg)) arg <span class="kw">else</span> <span class="lit">"*"</span> }</pre><h6>Argument Converters</h6><p>An <a href="scalop/index.html#ArgConverter[A]=String=&gt;Either[String,A]" name="com.loopfor.scalop.ArgConverter" id="com.loopfor.scalop.ArgConverter" class="extmbr">argument converter</a> is a function that transforms individual argument strings into other types. A
converter accepts as input:</p><ul><li>an argument string</li></ul><p>and returns an <code>Either[String, A]</code> where:</p><ul><li><code>Right(A)</code> conveys successful conversion to an instance of type <code>A</code></li><li><code>Left(String)</code> conveys failure with corresponding user-readable text</li></ul><p>A handful of implicit argument converters are provided in the <code>com.loopfor.scalop</code> package as a convenience for
constructing the most common option types. In the absence of a suitable converter, a custom implementation can be written
quite easily. The following example converts an argument string into its equivalent JDK logging level.</p><pre><span class="kw">import</span> java.util.logging.Level

<span class="kw">implicit</span> <span class="kw">def</span> argToLevel(arg: <span class="std">String</span>): Either[<span class="std">String</span>, Level] = {
  <span class="kw">try</span> Right(Level.parse(arg.toUpperCase)) <span class="kw">catch</span> {
    <span class="kw">case</span> _: IllegalArgumentException <span class="kw">=&gt;</span> Left(<span class="lit">"unrecognized level"</span>)
  }
}</pre><p>Providing this converter simplifies option construction as follows.</p><pre><span class="kw">val</span> opts = (<span class="lit">"level"</span>, <span class="lit">'L'</span>) ~&gt; as[Level] ~~ Level.OFF</pre></div></div></li></ul></div></div><div id="content"><body class="package value"><div id="definition"><div class="big-circle package">p</div><p id="owner"><a href="../index.html" name="com" id="com" class="extype">com</a></p><h1>loopfor<span class="permalink"><a href="../../com/loopfor/index.html" title="Permalink"><i class="material-icons"></i></a></span></h1></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">loopfor</span></span></h4><div id="comment" class="fullcommenttop"></div><div id="template"><div id="allMembers"><div id="packages" class="package members"><h3>Package Members</h3><ol><li class="indented0 " name="com.loopfor.scalop" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scalop"></a><a id="scalop:scalop"></a> <span class="permalink"><a href="../../com/loopfor/scalop/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="scalop/index.html" title="A simple option parser."><span class="name">scalop</span></a></span><p class="shortcomment cmt">A simple option parser.</p><div class="fullcomment"><div class="comment cmt"><p>A simple option parser.</p><h6>Overview</h6><p>An option parser is an ordered collection of <a href="scalop/OptName.html" name="com.loopfor.scalop.OptName" id="com.loopfor.scalop.OptName" class="extype">option name</a> and <a href="scalop/index.html#OptProcessor[+A]=Seq[String]=&gt;(Seq[String],A)" name="com.loopfor.scalop.OptProcessor" id="com.loopfor.scalop.OptProcessor" class="extmbr">option processor</a> pairs that
matches on a sequence of arguments, yielding a map of option names to option values. As the parser recognizes option names
in the argument sequence, it applies the corresponding processor function to obtain the option value. This process is
repeated until the argument sequence is exhausted or the parser encounters an error.</p><p>An <a href="scalop/OptName.html" name="com.loopfor.scalop.OptName" id="com.loopfor.scalop.OptName" class="extype">option name</a> can be expressed in both <i>long</i> and <i>short</i> form. For any given sequence of arguments,
<i>long</i> options are detected by the presence of a <code>--</code> prefix and <i>short</i> options with a <code>-</code> prefix. Examples include
<code>--verbose</code> and <code>-v</code>, respectively.</p><p>An <a href="scalop/index.html#OptProcessor[+A]=Seq[String]=&gt;(Seq[String],A)" name="com.loopfor.scalop.OptProcessor" id="com.loopfor.scalop.OptProcessor" class="extmbr">option processor</a> is an arbitrary function whose purpose is to return a value that gets assigned to the
option name. A processor may consider and absorb subsequent arguments in computing the value, such as <code>--timeout</code> that might
expect the next argument to be an integer. Library users are encouraged to utilize the predefined builder methods rather
than implement processor functions from scratch.</p><h6>Option Construction</h6><p>The construction of an <a href="scalop/Opt.html" name="com.loopfor.scalop.Opt" id="com.loopfor.scalop.Opt" class="extype">option</a> is best done using the DSL, which is available from the following import statement.</p><pre><span class="kw">import</span> com.loopfor.scalop._</pre><p>The following is a simple option that demonstrates how the DSL is used to pair an option name with a corresponding
processor.</p><pre><span class="kw">val</span> opt = (<span class="lit">"verbose"</span>, <span class="lit">'v'</span>) ~&gt; just(<span class="kw">true</span>)</pre><p>The <a href="scalop/OptName.html#~&gt;[A](fn:com.loopfor.scalop.OptProcessor[A]):com.loopfor.scalop.Opt[A]" name="com.loopfor.scalop.OptName#~&gt;" id="com.loopfor.scalop.OptName#~&gt;" class="extmbr">~&gt;</a> method triggers an implicit conversion of the tuple <code>("verbose", 'v')</code> into an option name and then
binds the processor function <code>just(true)</code>, resulting in an option.</p><p>An option can also be adorned with a default value upon construction using the <a href="scalop/Opt.html#~~[B&gt;:A](default:B):com.loopfor.scalop.Opt[B]" name="com.loopfor.scalop.Opt#~~" id="com.loopfor.scalop.Opt#~~" class="extmbr">~~</a> operator following the
processor function. Doing so ensures that the option is assigned the default value in the absence of being specified in an
argument sequence at the time of parsing.</p><pre><span class="kw">val</span> opt = (<span class="lit">"verbose"</span>, <span class="lit">'v'</span>) ~&gt; just(<span class="kw">true</span>) ~~ <span class="kw">false</span></pre><p>A sequence of options can then be constructed using the <code>::</code> operator. Note that the order of options is important since the
parser will evaluate arguments against those options based on traversal order of the sequence.</p><pre><span class="kw">val</span> opts = (<span class="lit">"verbose"</span>, <span class="lit">'v'</span>) ~&gt; just(<span class="kw">true</span>) ~~ <span class="kw">false</span> ::
           (<span class="lit">"timeout"</span>, <span class="lit">'t'</span>) ~&gt; as[<span class="std">Int</span>] ~~ <span class="num">0</span> ::
           <span class="lit">"encoding"</span> ~&gt; as[Charset] ~~ Charset.forName(<span class="lit">"UTF-8"</span>) ::
           <span class="lit">'?'</span> ~&gt; just(<span class="kw">true</span>) ~~ <span class="kw">false</span> ::
           Nil</pre><h6>Replacing Options</h6><p>A <i>replacing</i> option is one which replaces values previously assigned to an option name during argument parsing. Options
of this type are created using the <a href="scalop/OptName.html#~&gt;[A](fn:com.loopfor.scalop.OptProcessor[A]):com.loopfor.scalop.Opt[A]" name="com.loopfor.scalop.OptName#~&gt;" id="com.loopfor.scalop.OptName#~&gt;" class="extmbr">~&gt;</a> operator.</p><p>For example:</p><pre><span class="kw">val</span> opt = <span class="lit">"timeout"</span> ~&gt; as[<span class="std">Int</span>]</pre><p>Given the following sequence of arguments, the value of <code>timeout</code> at the completion of parsing would be <code>60</code>.</p><pre>--timeout <span class="num">30</span> --timeout <span class="num">60</span></pre><h6>Appending Options</h6><p>An <i>appending</i> option is one which appends values to a sequence of values previously assigned to an option name during
argument parsing. Options of this type are created using the <a href="scalop/OptName.html#~&gt;+[A](fn:com.loopfor.scalop.OptProcessor[A]):com.loopfor.scalop.Opt[A]" name="com.loopfor.scalop.OptName#~&gt;+" id="com.loopfor.scalop.OptName#~&gt;+" class="extmbr">~&gt;+</a> operator.</p><p>For example:</p><pre><span class="kw">val</span> opt = <span class="lit">"server"</span> ~&gt;+ as[<span class="std">String</span>]</pre><p>Given the following sequence of arguments, the value of <code>server</code> at the completion of parsing would be
<code>Seq("foo.com", "bar.com")</code>.</p><pre>--server foo.com --server bar.com</pre><h6>Parser Construction</h6><p>The construction of an <a href="scalop/OptParser.html" name="com.loopfor.scalop.OptParser" id="com.loopfor.scalop.OptParser" class="extype">option parser</a> happens implicitly when the <a href="scalop/OptParser.html#&lt;~(args:Seq[String]):com.loopfor.scalop.OptResult" name="com.loopfor.scalop.OptParser#&lt;~" id="com.loopfor.scalop.OptParser#&lt;~" class="extmbr">&lt;~</a> operator is applied to
either a single option or a sequence of options.</p><p>The following illustrates the evaluation of arguments against a sequence of options. Note that an ephemeral instance of
an option parser is constructed as a byproduct of applying the <code>&lt;~</code> operator.</p><pre><span class="kw">val</span> opts = (<span class="lit">"verbose"</span>, <span class="lit">'v'</span>) ~&gt; just(<span class="kw">true</span>) ~~ <span class="kw">false</span> ::
           (<span class="lit">"timeout"</span>, <span class="lit">'t'</span>) ~&gt; as[<span class="std">Int</span>] ~~ <span class="num">0</span> ::
           <span class="lit">"encoding"</span> ~&gt; as[Charset] ~~ Charset.forName(<span class="lit">"UTF-8"</span>) ::
           <span class="lit">'?'</span> ~&gt; just(<span class="kw">true</span>) ~~ <span class="kw">false</span> ::
           Nil

<span class="kw">val</span> optr = opts &lt;~ <span class="std">Seq</span>(<span class="lit">"--verbose"</span>, <span class="lit">"-t"</span>, <span class="lit">"30"</span>, <span class="lit">"--encoding"</span>, <span class="lit">"iso-8859-1"</span>, <span class="lit">"this"</span>, <span class="lit">"and"</span>, <span class="lit">"that"</span>)</pre><p>In the aforementioned example, invoking the parser with the given sequence of arguments produces an
<a href="scalop/OptResult.html" name="com.loopfor.scalop.OptResult" id="com.loopfor.scalop.OptResult" class="extype">option result</a> containing a map of option names to option values. Notice that a value is associated with both
<i>long</i> and <i>short</i> forms of the option name regardless of which form is specified in the argument sequence.</p><pre><span class="lit">"verbose"</span> -&gt; <span class="kw">true</span>
<span class="lit">"v"</span> -&gt; <span class="kw">true</span>
<span class="lit">"timeout"</span> -&gt; <span class="num">30</span>
<span class="lit">"t"</span> -&gt; <span class="num">30</span>
<span class="lit">"encoding"</span> -&gt; Charset(ISO-<span class="num">8859</span>-<span class="num">1</span>)
<span class="lit">"?"</span> -&gt; <span class="kw">false</span>
<span class="lit">"@"</span> -&gt; <span class="std">Seq</span>(<span class="lit">"this"</span>, <span class="lit">"and"</span>, <span class="lit">"that"</span>)</pre><p>The <code>@</code> option is a special name containing all non-option values trailing the last option in the argument sequence.</p><h6>Parser Behavior</h6><p>Given a sequence of arguments, such as those provided by a shell when supplying arguments to a command line program, an
option parser behaves in the following manner.</p><p>The parser recursively applies the following algorithm as it traverses the argument sequence.</p><ul><li>If the next argument is equal to <code>"--"</code>, the sequence of all subsequent arguments is assigned to the special option name
 <code>"@"</code> and the parser terminates, returning the option value map. By convention, the <code>--</code> option is used to explicitly
 terminate options so that remaining arguments, which might be prefixed with <code>--</code> or <code>-</code>, are not treated as options.</li><li>If the next argument is either a <i>long</i> or <i>short</i> option name recognized by the parser, the corresponding processor
 function is applied to the remaining arguments, yielding a value, which is then associated with the option name, both
 <i>long</i> and <i>short</i>, in the option value map. However, if the argument happens to be an option that is not recognized by
 the parser, then an <a href="scalop/OptException.html" name="com.loopfor.scalop.OptException" id="com.loopfor.scalop.OptException" class="extype">exception</a> is thrown. Otherwise, the parser is recursively applied to the remaining
 sequence of arguments.</li><li>If the next argument is not an option, implying that it contains neither a <code>--</code> nor a <code>-</code> prefix, then the remaining
 argument sequence is assigned to the <code>"@"</code> option and the parser terminates.</li></ul><p>Finally, default values for each option are assigned to the option value map if values for those corresponding options are
absent.</p><p>In cases where values, which follow an option, contain either a <code>-</code> or <code>--</code> prefix, such values must be escaped by
prepending the <code>\</code> character. Otherwise, the parser will interpret the value as an option and proceed accordingly.</p><p>The following example will parse incorrectly since <code>-10</code> will be interpreted as an option.</p><pre>--time-adjust -<span class="num">10</span></pre><p>The correct way to specify this value is as follows:</p><pre>--time-adjust \-<span class="num">10</span></pre><h6>Option Processors</h6><p>An <a href="scalop/index.html#OptProcessor[+A]=Seq[String]=&gt;(Seq[String],A)" name="com.loopfor.scalop.OptProcessor" id="com.loopfor.scalop.OptProcessor" class="extmbr">option processor</a> is a function accepting as input:</p><ul><li>the sequence of arguments that follow an option name</li></ul><p>and returning as output a tuple containing:</p><ul><li>the sequence of arguments following those consumed by the processor</li><li>the option value</li></ul><p>The argument sequence provided as input are those that follow the recognized option. For example, given the following
argument sequence:</p><p><pre>
--verbose -F foo.out --timeout 10
</pre></p><p>Assuming <code>-F</code> was recognized by the parser, then the sequence provided to the associated processor function would be:</p><pre><span class="std">Seq</span>(<span class="lit">"foo.out"</span>, <span class="lit">"--timeout"</span>, <span class="lit">"10"</span>)</pre><p>Since a processor may expect additional arguments following the option, as is the case with <code>-F</code>, the resulting sequence
will be the arguments that follow those absorbed by the processor, which in this case, would be:</p><pre><span class="std">Seq</span>(<span class="lit">"--timeout"</span>, <span class="lit">"10"</span>)</pre><p>In cases where a processor requires additional arguments, it is often necessary to perform some degree of validation or
transformation, both of which may fail. Exceptions that propagate beyond the processor function are caught by the parser
and converted to <a href="scalop/OptException.html" name="com.loopfor.scalop.OptException" id="com.loopfor.scalop.OptException" class="extype">OptException</a>. Additionally, the <code>yell()</code> methods are provided as a convenience for processor
implementations to throw instances of <a href="scalop/OptException.html" name="com.loopfor.scalop.OptException" id="com.loopfor.scalop.OptException" class="extype">OptException</a>.</p><h6>Processor Construction</h6><p>A processor is typically constructed using one of the predefined builders, the choice of which depends on the nature of the
option.</p><p>For standalone options with no additional argument, the <a href="scalop/index.html#just[A](fn:=&gt;A):com.loopfor.scalop.package.OptProcessor[A]" name="com.loopfor.scalop#just" id="com.loopfor.scalop#just" class="extmbr">just</a> builder can be used to explicitly assign a value.</p><pre>(<span class="lit">"verbose"</span>, <span class="lit">'v'</span>) ~&gt; just(<span class="kw">true</span>)</pre><p>For options that contain one additional argument, the <a href="scalop/index.html#as[A,B](fn:A=&gt;B)(implicitconverter:com.loopfor.scalop.package.ArgConverter[A]):com.loopfor.scalop.package.OptProcessor[B]" name="com.loopfor.scalop#as" id="com.loopfor.scalop#as" class="extmbr">as</a> builders simplify
construction of the processor by standardizing the manner in which error cases are handled, such as missing arguments and
problems encountered with argument converters.</p><p>The simplest form of using <a href="scalop/index.html#as[A](implicitconverter:com.loopfor.scalop.package.ArgConverter[A]):com.loopfor.scalop.package.OptProcessor[A]" name="com.loopfor.scalop#as" id="com.loopfor.scalop#as" class="extmbr">as</a> follows, which essentially converts the argument into
the parameterized type.</p><pre>(<span class="lit">"timeout"</span>, <span class="lit">'t'</span>) ~&gt; as[<span class="std">Int</span>]</pre><p>As with all uses of <code>as</code>, an <a href="scalop/index.html#ArgConverter[A]=String=&gt;Either[String,A]" name="com.loopfor.scalop.ArgConverter" id="com.loopfor.scalop.ArgConverter" class="extmbr">argument converter</a> must be implicitly defined or supplied directly to the
function. Argument converters are discussed in more detail below.</p><p>A secondary form of using <a href="scalop/index.html#as[A,B](fn:A=&gt;B)(implicitconverter:com.loopfor.scalop.package.ArgConverter[A]):com.loopfor.scalop.package.OptProcessor[B]" name="com.loopfor.scalop#as" id="com.loopfor.scalop#as" class="extmbr">as</a> accepts a user-supplied function, which performs
additional processing on the argument once converted. The result of that function becomes the value of the option.</p><p>The following example illustrates how a function can be used for validation or alteration.</p><pre>(<span class="lit">"timeout"</span>, <span class="lit">'t'</span>) ~&gt; as { arg: <span class="std">Int</span> <span class="kw">=&gt;</span> <span class="kw">if</span> (arg &lt; <span class="num">0</span>) <span class="num">0</span> <span class="kw">else</span> arg }</pre><p>The type of the return value does not need to match the type of the converted argument, which is demonstrated below.</p><pre>(<span class="lit">"timeout"</span>, <span class="lit">'t'</span>) ~&gt; as { arg: <span class="std">Int</span> <span class="kw">=&gt;</span> (<span class="kw">if</span> (arg &lt; <span class="num">0</span>) <span class="num">0</span> <span class="kw">else</span> arg).seconds }</pre><p>For options that <i>might</i> contain an additional argument, the <a href="scalop/index.html#maybe[A,B](fn:A=&gt;B)(implicitconverter:com.loopfor.scalop.package.ArgConverter[A]):com.loopfor.scalop.package.OptProcessor[Option[B]]" name="com.loopfor.scalop#maybe" id="com.loopfor.scalop#maybe" class="extmbr">maybe</a> builders
are similar to their <code>as</code> counterparts in that the handling of error cases is standardized. All processors constructed in
this manner yield <code>Option[A]</code> rather than <code>A</code>. This is necessary to distinguish between the presence or absence of a
subsequent argument.</p><p>The simplest form of using <a href="scalop/index.html#maybe[A](implicitconverter:com.loopfor.scalop.package.ArgConverter[A]):com.loopfor.scalop.package.OptProcessor[Option[A]]" name="com.loopfor.scalop#maybe" id="com.loopfor.scalop#maybe" class="extmbr">maybe</a> is demonstrated below.</p><pre><span class="kw">val</span> opts = <span class="lit">"help"</span> ~&gt; maybe[<span class="std">String</span>]</pre><p>The value of the option will vary depending on the arguments provided to the parser:</p><pre>optr = opts &lt;~ <span class="std">Seq</span>()
optr(<span class="lit">"help"</span>) <span class="cmt">// undefined</span>

optr = opts &lt;~ <span class="std">Seq</span>(<span class="lit">"--help"</span>)
optr(<span class="lit">"help"</span>) == <span class="std">None</span>

optr = opts &lt;~ <span class="std">Seq</span>(<span class="lit">"--help"</span>, <span class="lit">"foo"</span>)
optr(<span class="lit">"help"</span>) == <span class="std">Some</span>(<span class="lit">"foo"</span>)</pre><p>A secondary form of using <a href="scalop/index.html#maybe[A,B](fn:A=&gt;B)(implicitconverter:com.loopfor.scalop.package.ArgConverter[A]):com.loopfor.scalop.package.OptProcessor[Option[B]]" name="com.loopfor.scalop#maybe" id="com.loopfor.scalop#maybe" class="extmbr">maybe</a> accepts a user-supplied function, but is
invoked only if a subsequent argument is present.</p><pre><span class="lit">"help"</span> ~&gt; maybe { arg: <span class="std">String</span> <span class="kw">=&gt;</span> <span class="kw">if</span> (canHelp(arg)) arg <span class="kw">else</span> <span class="lit">"*"</span> }</pre><h6>Argument Converters</h6><p>An <a href="scalop/index.html#ArgConverter[A]=String=&gt;Either[String,A]" name="com.loopfor.scalop.ArgConverter" id="com.loopfor.scalop.ArgConverter" class="extmbr">argument converter</a> is a function that transforms individual argument strings into other types. A
converter accepts as input:</p><ul><li>an argument string</li></ul><p>and returns an <code>Either[String, A]</code> where:</p><ul><li><code>Right(A)</code> conveys successful conversion to an instance of type <code>A</code></li><li><code>Left(String)</code> conveys failure with corresponding user-readable text</li></ul><p>A handful of implicit argument converters are provided in the <code>com.loopfor.scalop</code> package as a convenience for
constructing the most common option types. In the absence of a suitable converter, a custom implementation can be written
quite easily. The following example converts an argument string into its equivalent JDK logging level.</p><pre><span class="kw">import</span> java.util.logging.Level

<span class="kw">implicit</span> <span class="kw">def</span> argToLevel(arg: <span class="std">String</span>): Either[<span class="std">String</span>, Level] = {
  <span class="kw">try</span> Right(Level.parse(arg.toUpperCase)) <span class="kw">catch</span> {
    <span class="kw">case</span> _: IllegalArgumentException <span class="kw">=&gt;</span> Left(<span class="lit">"unrecognized level"</span>)
  }
}</pre><p>Providing this converter simplifies option construction as follows.</p><pre><span class="kw">val</span> opts = (<span class="lit">"level"</span>, <span class="lit">'L'</span>) ~&gt; as[Level] ~~ Level.OFF</pre></div></div></li></ol></div></div><div id="inheritedMembers"></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
